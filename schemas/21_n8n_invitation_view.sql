-- Create a simplified view for n8n to insert invitations
-- This view handles the complex field mapping and defaults

CREATE OR REPLACE VIEW api.n8n_invitations AS
SELECT * FROM api.invitations;

-- Create an INSTEAD OF INSERT trigger to handle the insertion logic
CREATE OR REPLACE FUNCTION api.n8n_invitations_insert_trigger()
RETURNS TRIGGER AS $$
DECLARE
  client_uuid UUID;
  app_uuid UUID;
BEGIN
  -- Resolve client_id from code or use default
  IF NEW.client_id IS NULL THEN
    client_uuid := (SELECT id FROM api.clients WHERE code = 'THEPIA' LIMIT 1);
  ELSE
    client_uuid := NEW.client_id;
  END IF;

  -- Resolve app_id from code or use default
  IF NEW.app_id IS NULL THEN
    app_uuid := (SELECT id FROM api.client_applications WHERE client_id = client_uuid AND code = 'FLOWS' LIMIT 1);
  ELSE
    app_uuid := NEW.app_id;
  END IF;

  -- Insert into the actual invitations table with defaults
  INSERT INTO api.invitations (
    -- Core required fields
    client_id,
    app_id,
    jwt_token_hash,
    created_by,
    expires_at,
    
    -- Optional fields with defaults
    invitation_code,
    permissions,
    restrictions,
    status,
    max_uses,
    client_data,
    
    -- Extended demo fields
    jwt_token,
    email_hash,
    email_domain,
    retention_purpose,
    auto_delete_at,
    demo_duration,
    team_size,
    timeline,
    role,
    request_type,
    spam_score,
    spam_status,
    workflow_type,
    comment
  ) VALUES (
    -- Core required fields
    client_uuid,
    app_uuid,
    COALESCE(NEW.jwt_token_hash, 'MISSING_JWT_HASH_' || gen_random_uuid()::TEXT),
    COALESCE(NEW.created_by, 'n8n-automation'),
    COALESCE(NEW.expires_at, NOW() + INTERVAL '14 days'),
    
    -- Optional fields with defaults
    COALESCE(NEW.invitation_code, api.generate_invitation_code(client_uuid, app_uuid)),
    COALESCE(NEW.permissions, '[]'::JSONB),
    COALESCE(NEW.restrictions, '{}'::JSONB),
    COALESCE(NEW.status, 'requested'),
    COALESCE(NEW.max_uses, 1),
    COALESCE(NEW.client_data, '{}'::JSONB),
    
    -- Extended demo fields
    NEW.jwt_token,
    NEW.email_hash,
    NEW.email_domain,
    COALESCE(NEW.retention_purpose, 'demo_invitation'),
    COALESCE(NEW.auto_delete_at, NOW() + INTERVAL '90 days'),
    NEW.demo_duration,
    NEW.team_size,
    NEW.timeline,
    NEW.role,
    COALESCE(NEW.request_type, 'demo'),
    COALESCE(NEW.spam_score, 0),
    COALESCE(NEW.spam_status, 'clean'),
    NEW.workflow_type,
    NEW.comment
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create the trigger
DROP TRIGGER IF EXISTS n8n_invitations_insert ON api.n8n_invitations;
CREATE TRIGGER n8n_invitations_insert
  INSTEAD OF INSERT ON api.n8n_invitations
  FOR EACH ROW
  EXECUTE FUNCTION api.n8n_invitations_insert_trigger();

-- Grant permissions
GRANT SELECT, INSERT ON api.n8n_invitations TO authenticated;

-- Add helpful comment
COMMENT ON VIEW api.n8n_invitations IS 'Simplified view for n8n to insert invitations. Handles defaults and field mapping automatically.';

-- Alternative: Create a simple wrapper table that n8n can insert into
-- This table accepts minimal fields and a trigger processes them
CREATE TABLE IF NOT EXISTS api.n8n_invitation_requests (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  -- Minimal required fields from n8n
  name TEXT NOT NULL,
  email TEXT NOT NULL,
  company TEXT,
  message TEXT,
  type TEXT DEFAULT 'demo',
  spam_score INTEGER DEFAULT 0,
  spam_status TEXT DEFAULT 'clean',
  priority TEXT DEFAULT 'normal',
  request_id TEXT,
  
  -- JWT fields (optional - can be generated by trigger if missing)
  jwt_token TEXT,
  jwt_token_hash TEXT,
  email_hash TEXT,
  
  -- Demo-specific fields
  demo_duration TEXT,
  team_size TEXT,
  timeline TEXT,
  role TEXT,
  use_case TEXT,
  
  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  processed BOOLEAN DEFAULT FALSE,
  invitation_id UUID REFERENCES api.invitations(id)
);

-- Create trigger to process n8n requests into invitations
CREATE OR REPLACE FUNCTION api.process_n8n_invitation_request()
RETURNS TRIGGER AS $$
DECLARE
  client_uuid UUID;
  app_uuid UUID;
  new_invitation_id UUID;
BEGIN
  -- Skip if already processed
  IF NEW.processed = TRUE THEN
    RETURN NEW;
  END IF;

  -- Get default client and app
  client_uuid := (SELECT id FROM api.clients WHERE code = 'THEPIA' LIMIT 1);
  app_uuid := (SELECT id FROM api.client_applications WHERE client_id = client_uuid AND code = 'FLOWS' LIMIT 1);

  -- Create the invitation
  INSERT INTO api.invitations (
    client_id,
    app_id,
    jwt_token_hash,
    created_by,
    expires_at,
    status,
    client_data,
    
    -- Extended fields
    jwt_token,
    email_hash,
    email_domain,
    retention_purpose,
    demo_duration,
    team_size,
    timeline,
    role,
    request_type,
    spam_score,
    spam_status,
    workflow_type,
    comment
  ) VALUES (
    client_uuid,
    app_uuid,
    COALESCE(NEW.jwt_token_hash, 'PENDING_' || gen_random_uuid()::TEXT),
    'n8n-automation',
    NOW() + INTERVAL '14 days',
    'requested',
    jsonb_build_object(
      'name', NEW.name,
      'company', NEW.company,
      'email', NEW.email,
      'request_id', NEW.request_id
    ),
    
    NEW.jwt_token,
    NEW.email_hash,
    SPLIT_PART(NEW.email, '@', 2),
    'demo_invitation',
    NEW.demo_duration,
    NEW.team_size,
    NEW.timeline,
    NEW.role,
    NEW.type,
    NEW.spam_score,
    NEW.spam_status,
    NEW.use_case,
    NEW.message
  )
  RETURNING id INTO new_invitation_id;

  -- Update the request as processed
  NEW.processed := TRUE;
  NEW.invitation_id := new_invitation_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger
CREATE TRIGGER process_n8n_request_after_insert
  AFTER INSERT ON api.n8n_invitation_requests
  FOR EACH ROW
  EXECUTE FUNCTION api.process_n8n_invitation_request();

-- Grant permissions
GRANT SELECT, INSERT ON api.n8n_invitation_requests TO authenticated;

COMMENT ON TABLE api.n8n_invitation_requests IS 'Simple table for n8n to insert invitation requests. A trigger automatically creates proper invitation records.';